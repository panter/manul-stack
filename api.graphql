### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

type BlogPost {
  author: User!
  content: String!
  id: String!
  published: Boolean!
  title: String!
}

input BlogPostCreateInput {
  author: UserCreateOneWithoutBlogPostsInput!
  content: String!
  id: String
  published: Boolean
  title: String!
}

input BlogPostCreateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
}

input BlogPostCreateWithoutAuthorInput {
  content: String!
  id: String
  published: Boolean
  title: String!
}

input BlogPostFilter {
  every: BlogPostWhereInput
  none: BlogPostWhereInput
  some: BlogPostWhereInput
}

input BlogPostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
}

input BlogPostScalarWhereInput {
  AND: [BlogPostScalarWhereInput!]
  authorId: StringFilter
  content: StringFilter
  id: UUIDFilter
  NOT: [BlogPostScalarWhereInput!]
  OR: [BlogPostScalarWhereInput!]
  published: BooleanFilter
  title: StringFilter
}

input BlogPostUpdateInput {
  author: UserUpdateOneRequiredWithoutBlogPostsInput
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateManyDataInput {
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateManyMutationInput {
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
  delete: [BlogPostWhereUniqueInput!]
  deleteMany: [BlogPostScalarWhereInput!]
  disconnect: [BlogPostWhereUniqueInput!]
  set: [BlogPostWhereUniqueInput!]
  update: [BlogPostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BlogPostUpdateManyWithWhereNestedInput!]
  upsert: [BlogPostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogPostUpdateManyWithWhereNestedInput {
  data: BlogPostUpdateManyDataInput!
  where: BlogPostScalarWhereInput!
}

input BlogPostUpdateWithoutAuthorDataInput {
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateWithWhereUniqueWithoutAuthorInput {
  data: BlogPostUpdateWithoutAuthorDataInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostUpsertWithWhereUniqueWithoutAuthorInput {
  create: BlogPostCreateWithoutAuthorInput!
  update: BlogPostUpdateWithoutAuthorDataInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostWhereInput {
  AND: [BlogPostWhereInput!]
  author: UserWhereInput
  authorId: StringFilter
  content: StringFilter
  id: UUIDFilter
  NOT: [BlogPostWhereInput!]
  OR: [BlogPostWhereInput!]
  published: BooleanFilter
  title: StringFilter
}

input BlogPostWhereUniqueInput {
  id: String
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LoginResult {
  user: User
}

type Mutation {
  adminCreateOneBlogPost(data: BlogPostCreateInput!): BlogPost!
  adminCreateOneProduct(data: ProductCreateInput!): Product!
  adminCreateOneUser(data: UserCreateInput!): User!
  adminDeleteManyBlogPost(where: BlogPostWhereInput): BatchPayload!
  adminDeleteManyProduct(where: ProductWhereInput): BatchPayload!
  adminDeleteManyUser(where: UserWhereInput): BatchPayload!
  adminDeleteOneBlogPost(where: BlogPostWhereUniqueInput!): BlogPost
  adminDeleteOneProduct(where: ProductWhereUniqueInput!): Product
  adminDeleteOneUser(where: UserWhereUniqueInput!): User
  adminUpdateManyBlogPost(data: BlogPostUpdateManyMutationInput!, where: BlogPostWhereInput): BatchPayload!
  adminUpdateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  adminUpdateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  adminUpdateOneBlogPost(data: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost
  adminUpdateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  adminUpdateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  adminUpsertOneBlogPost(create: BlogPostCreateInput!, update: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost!
  adminUpsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  adminUpsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  login(email: String!, password: String!): LoginResult
  logout: Boolean
  signup(email: String!, password: String!): SignupResult
  upsertCart: Order
}

type Order {
  created: DateTime!
  id: String!
  products(cursor: ProductWhereUniqueInput, skip: Int, take: Int): [Product!]!
  type: String!
}

input OrderCreateManyWithoutProductsInput {
  connect: [OrderWhereUniqueInput!]
  create: [OrderCreateWithoutProductsInput!]
}

input OrderCreateWithoutProductsInput {
  created: DateTime!
  id: String
  type: String!
}

input OrderFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

input OrderScalarWhereInput {
  AND: [OrderScalarWhereInput!]
  created: DateTimeFilter
  id: UUIDFilter
  NOT: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  products: ProductFilter
  type: StringFilter
}

input OrderUpdateManyDataInput {
  created: DateTime
  id: String
  type: String
}

input OrderUpdateManyWithoutProductsInput {
  connect: [OrderWhereUniqueInput!]
  create: [OrderCreateWithoutProductsInput!]
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutProductsInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutProductsInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  data: OrderUpdateManyDataInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateWithoutProductsDataInput {
  created: DateTime
  id: String
  type: String
}

input OrderUpdateWithWhereUniqueWithoutProductsInput {
  data: OrderUpdateWithoutProductsDataInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithWhereUniqueWithoutProductsInput {
  create: OrderCreateWithoutProductsInput!
  update: OrderUpdateWithoutProductsDataInput!
  where: OrderWhereUniqueInput!
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  created: DateTimeFilter
  id: UUIDFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  products: ProductFilter
  type: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

type Product {
  description: String!
  id: String!
  slug: String!
  title: String!
}

input ProductCreateInput {
  description: String!
  id: String
  orders: OrderCreateManyWithoutProductsInput
  slug: String!
  title: String!
}

input ProductFilter {
  every: ProductWhereInput
  none: ProductWhereInput
  some: ProductWhereInput
}

input ProductOrderByInput {
  description: SortOrder
  id: SortOrder
  slug: SortOrder
  title: SortOrder
}

input ProductUpdateInput {
  description: String
  id: String
  orders: OrderUpdateManyWithoutProductsInput
  slug: String
  title: String
}

input ProductUpdateManyMutationInput {
  description: String
  id: String
  slug: String
  title: String
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  description: StringFilter
  id: UUIDFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  orders: OrderFilter
  slug: StringFilter
  title: StringFilter
}

input ProductWhereUniqueInput {
  id: String
  slug: String
}

type Query {
  adminBlogPost(where: BlogPostWhereUniqueInput!): BlogPost
  adminBlogPosts(cursor: BlogPostWhereUniqueInput, orderBy: [BlogPostOrderByInput!], skip: Int, take: Int, where: BlogPostWhereInput): [BlogPost!]!
  adminBlogPostsCount(cursor: BlogPostWhereUniqueInput, orderBy: BlogPostOrderByInput, skip: Int, take: Int, where: BlogPostWhereInput): Int
  adminProduct(where: ProductWhereUniqueInput!): Product
  adminProducts(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  adminProductsCount(cursor: ProductWhereUniqueInput, orderBy: ProductOrderByInput, skip: Int, take: Int, where: ProductWhereInput): Int
  adminUser(where: UserWhereUniqueInput!): User
  adminUsers(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  adminUsersCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int
  blogPosts(cursor: BlogPostWhereUniqueInput, skip: Int, take: Int, where: BlogPostWhereInput): [BlogPost!]!
  me: User
  products(cursor: ProductWhereUniqueInput, skip: Int, take: Int, where: ProductWhereInput): [Product!]!
}

type SignupResult {
  user: User
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input UpsertCartInput {
  products: [UpsertCartProductsInput!]
}

input UpsertCartProductsInput {
  productId: String
  quantity: Int
}

type User {
  blogPosts(cursor: BlogPostWhereUniqueInput, skip: Int, take: Int): [BlogPost!]!
  email: String!
  id: String!
  roles(cursor: UserRoleWhereUniqueInput, skip: Int, take: Int): [UserRole!]!
}

input UserCreateInput {
  blogPosts: BlogPostCreateManyWithoutAuthorInput
  email: String!
  id: String
  password: String!
  roles: UserRoleCreateManyWithoutUsersInput
}

input UserCreateOneWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBlogPostsInput
}

input UserCreateWithoutBlogPostsInput {
  email: String!
  id: String
  password: String!
  roles: UserRoleCreateManyWithoutUsersInput
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  email: SortOrder
  id: SortOrder
  password: SortOrder
}

type UserRole {
  id: String!
}

input UserRoleCreateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
}

input UserRoleCreateWithoutUsersInput {
  id: String!
}

input UserRoleFilter {
  every: UserRoleWhereInput
  none: UserRoleWhereInput
  some: UserRoleWhereInput
}

input UserRoleScalarWhereInput {
  AND: [UserRoleScalarWhereInput!]
  id: StringFilter
  NOT: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  users: UserFilter
}

input UserRoleUpdateManyDataInput {
  id: String
}

input UserRoleUpdateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
  delete: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  update: [UserRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [UserRoleUpdateManyWithWhereNestedInput!]
  upsert: [UserRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input UserRoleUpdateManyWithWhereNestedInput {
  data: UserRoleUpdateManyDataInput!
  where: UserRoleScalarWhereInput!
}

input UserRoleUpdateWithoutUsersDataInput {
  id: String
}

input UserRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: UserRoleCreateWithoutUsersInput!
  update: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleWhereInput {
  AND: [UserRoleWhereInput!]
  id: StringFilter
  NOT: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  users: UserFilter
}

input UserRoleWhereUniqueInput {
  id: String
}

input UserUpdateInput {
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  email: String
  id: String
  password: String
  roles: UserRoleUpdateManyWithoutUsersInput
}

input UserUpdateManyMutationInput {
  email: String
  id: String
  password: String
}

input UserUpdateOneRequiredWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBlogPostsInput
  update: UserUpdateWithoutBlogPostsDataInput
  upsert: UserUpsertWithoutBlogPostsInput
}

input UserUpdateWithoutBlogPostsDataInput {
  email: String
  id: String
  password: String
  roles: UserRoleUpdateManyWithoutUsersInput
}

input UserUpsertWithoutBlogPostsInput {
  create: UserCreateWithoutBlogPostsInput!
  update: UserUpdateWithoutBlogPostsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  blogPosts: BlogPostFilter
  email: StringFilter
  id: UUIDFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  roles: UserRoleFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
