### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

type BlogPost {
  author: User!
  content: Json
  id: String!
  published: Boolean!
  title: String!
}

input BlogPostCreateInput {
  author: UserCreateOneWithoutBlogPostsInput!
  content: String
  id: String
  published: Boolean
  title: String!
}

input BlogPostCreateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
}

input BlogPostCreateWithoutAuthorInput {
  content: String
  id: String
  published: Boolean
  title: String!
}

input BlogPostFilter {
  every: BlogPostWhereInput
  none: BlogPostWhereInput
  some: BlogPostWhereInput
}

input BlogPostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
}

input BlogPostScalarWhereInput {
  AND: [BlogPostScalarWhereInput!]
  authorId: StringFilter
  content: NullableStringFilter
  id: UUIDFilter
  NOT: [BlogPostScalarWhereInput!]
  OR: [BlogPostScalarWhereInput!]
  published: BooleanFilter
  title: StringFilter
}

input BlogPostUpdateInput {
  author: UserUpdateOneRequiredWithoutBlogPostsInput
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateManyDataInput {
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateManyMutationInput {
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
  delete: [BlogPostWhereUniqueInput!]
  deleteMany: [BlogPostScalarWhereInput!]
  disconnect: [BlogPostWhereUniqueInput!]
  set: [BlogPostWhereUniqueInput!]
  update: [BlogPostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BlogPostUpdateManyWithWhereNestedInput!]
  upsert: [BlogPostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogPostUpdateManyWithWhereNestedInput {
  data: BlogPostUpdateManyDataInput!
  where: BlogPostScalarWhereInput!
}

input BlogPostUpdateWithoutAuthorDataInput {
  content: String
  id: String
  published: Boolean
  title: String
}

input BlogPostUpdateWithWhereUniqueWithoutAuthorInput {
  data: BlogPostUpdateWithoutAuthorDataInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostUpsertWithWhereUniqueWithoutAuthorInput {
  create: BlogPostCreateWithoutAuthorInput!
  update: BlogPostUpdateWithoutAuthorDataInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostWhereInput {
  AND: [BlogPostWhereInput!]
  author: UserWhereInput
  authorId: StringFilter
  content: NullableStringFilter
  id: UUIDFilter
  NOT: [BlogPostWhereInput!]
  OR: [BlogPostWhereInput!]
  published: BooleanFilter
  title: StringFilter
}

input BlogPostWhereUniqueInput {
  id: String
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LoginResult {
  user: User
}

type Mutation {
  adminCreateOneBlogPost(data: BlogPostCreateInput!): BlogPost!
  adminCreateOnePage(data: PageCreateInput!): Page!
  adminCreateOneUser(data: UserCreateInput!): User!
  adminDeleteManyBlogPost(where: BlogPostWhereInput): BatchPayload!
  adminDeleteManyPage(where: PageWhereInput): BatchPayload!
  adminDeleteManyUser(where: UserWhereInput): BatchPayload!
  adminDeleteOneBlogPost(where: BlogPostWhereUniqueInput!): BlogPost
  adminDeleteOnePage(where: PageWhereUniqueInput!): Page
  adminDeleteOneUser(where: UserWhereUniqueInput!): User
  adminUpdateManyBlogPost(data: BlogPostUpdateManyMutationInput!, where: BlogPostWhereInput): BatchPayload!
  adminUpdateManyPage(data: PageUpdateManyMutationInput!, where: PageWhereInput): BatchPayload!
  adminUpdateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  adminUpdateOneBlogPost(data: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost
  adminUpdateOnePage(data: PageUpdateInput!, where: PageWhereUniqueInput!): Page
  adminUpdateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  adminUpsertOneBlogPost(create: BlogPostCreateInput!, update: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost!
  adminUpsertOnePage(create: PageCreateInput!, update: PageUpdateInput!, where: PageWhereUniqueInput!): Page!
  adminUpsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  login(email: String!, password: String!): LoginResult
  logout: Boolean
  signup(email: String!, password: String!): SignupResult
  uploadFile(file: Upload, fileName: String): String
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Page {
  childPages(cursor: PageWhereUniqueInput, orderBy: [PageOrderByInput!], skip: Int, take: Int): [Page!]!
  content: Json
  htmlTitle: String!
  htmlTitle_de: String
  htmlTitle_en: String
  id: String!
  meta_description: String!
  meta_description_de: String
  meta_description_en: String
  navigationTitle: String!
  navigationTitle_de: String
  navigationTitle_en: String
  parentPage: Page
  path: String
  published: Boolean
  slug: String!
  social_description: String!
  social_description_de: String
  social_description_en: String
  social_title: String!
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageCreateInput {
  childPages: PageCreateManyWithoutParentPageInput
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String!
  parentPage: PageCreateOneWithoutChildPagesInput
  published: Boolean
  slug: String!
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageCreateManyWithoutParentPageInput {
  connect: [PageWhereUniqueInput!]
  create: [PageCreateWithoutParentPageInput!]
}

input PageCreateOneWithoutChildPagesInput {
  connect: PageWhereUniqueInput
  create: PageCreateWithoutChildPagesInput
}

input PageCreateWithoutChildPagesInput {
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String!
  parentPage: PageCreateOneWithoutChildPagesInput
  path: String
  published: Boolean
  slug: String!
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageCreateWithoutParentPageInput {
  childPages: PageCreateManyWithoutParentPageInput
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String!
  path: String
  published: Boolean
  slug: String!
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageFilter {
  every: PageWhereInput
  none: PageWhereInput
  some: PageWhereInput
}

input PageOrderByInput {
  content: SortOrder
  createdAt: SortOrder
  htmlTitle_de: SortOrder
  htmlTitle_en: SortOrder
  id: SortOrder
  meta_description_de: SortOrder
  meta_description_en: SortOrder
  navigationTitle_de: SortOrder
  navigationTitle_en: SortOrder
  parentPageId: SortOrder
  path: SortOrder
  published: SortOrder
  slug: SortOrder
  social_description_de: SortOrder
  social_description_en: SortOrder
  social_title_de: SortOrder
  social_title_en: SortOrder
  sortKey: SortOrder
}

input PageScalarWhereInput {
  AND: [PageScalarWhereInput!]
  childPages: PageFilter
  content: NullableStringFilter
  createdAt: DateTimeFilter
  htmlTitle_de: NullableStringFilter
  htmlTitle_en: NullableStringFilter
  id: UUIDFilter
  meta_description_de: NullableStringFilter
  meta_description_en: NullableStringFilter
  navigationTitle_de: NullableStringFilter
  navigationTitle_en: StringFilter
  NOT: [PageScalarWhereInput!]
  OR: [PageScalarWhereInput!]
  parentPageId: NullableStringFilter
  path: NullableStringFilter
  published: NullableBooleanFilter
  slug: StringFilter
  social_description_de: NullableStringFilter
  social_description_en: NullableStringFilter
  social_title_de: NullableStringFilter
  social_title_en: NullableStringFilter
  sortKey: NullableIntFilter
}

input PageUpdateInput {
  childPages: PageUpdateManyWithoutParentPageInput
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String
  parentPage: PageUpdateOneWithoutChildPagesInput
  published: Boolean
  slug: String
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageUpdateManyDataInput {
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String
  path: String
  published: Boolean
  slug: String
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageUpdateManyMutationInput {
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String
  path: String
  published: Boolean
  slug: String
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageUpdateManyWithoutParentPageInput {
  connect: [PageWhereUniqueInput!]
  create: [PageCreateWithoutParentPageInput!]
  delete: [PageWhereUniqueInput!]
  deleteMany: [PageScalarWhereInput!]
  disconnect: [PageWhereUniqueInput!]
  set: [PageWhereUniqueInput!]
  update: [PageUpdateWithWhereUniqueWithoutParentPageInput!]
  updateMany: [PageUpdateManyWithWhereNestedInput!]
  upsert: [PageUpsertWithWhereUniqueWithoutParentPageInput!]
}

input PageUpdateManyWithWhereNestedInput {
  data: PageUpdateManyDataInput!
  where: PageScalarWhereInput!
}

input PageUpdateOneWithoutChildPagesInput {
  connect: PageWhereUniqueInput
  create: PageCreateWithoutChildPagesInput
  delete: Boolean
  disconnect: Boolean
  update: PageUpdateWithoutChildPagesDataInput
  upsert: PageUpsertWithoutChildPagesInput
}

input PageUpdateWithoutChildPagesDataInput {
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String
  parentPage: PageUpdateOneWithoutChildPagesInput
  path: String
  published: Boolean
  slug: String
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageUpdateWithoutParentPageDataInput {
  childPages: PageUpdateManyWithoutParentPageInput
  content: String
  createdAt: DateTime
  htmlTitle_de: String
  htmlTitle_en: String
  id: String
  meta_description_de: String
  meta_description_en: String
  navigationTitle_de: String
  navigationTitle_en: String
  path: String
  published: Boolean
  slug: String
  social_description_de: String
  social_description_en: String
  social_title_de: String
  social_title_en: String
  sortKey: Int
}

input PageUpdateWithWhereUniqueWithoutParentPageInput {
  data: PageUpdateWithoutParentPageDataInput!
  where: PageWhereUniqueInput!
}

input PageUpsertWithoutChildPagesInput {
  create: PageCreateWithoutChildPagesInput!
  update: PageUpdateWithoutChildPagesDataInput!
}

input PageUpsertWithWhereUniqueWithoutParentPageInput {
  create: PageCreateWithoutParentPageInput!
  update: PageUpdateWithoutParentPageDataInput!
  where: PageWhereUniqueInput!
}

input PageWhereInput {
  AND: [PageWhereInput!]
  childPages: PageFilter
  content: NullableStringFilter
  createdAt: DateTimeFilter
  htmlTitle_de: NullableStringFilter
  htmlTitle_en: NullableStringFilter
  id: UUIDFilter
  meta_description_de: NullableStringFilter
  meta_description_en: NullableStringFilter
  navigationTitle_de: NullableStringFilter
  navigationTitle_en: StringFilter
  NOT: [PageWhereInput!]
  OR: [PageWhereInput!]
  parentPage: PageWhereInput
  parentPageId: NullableStringFilter
  path: NullableStringFilter
  published: NullableBooleanFilter
  slug: StringFilter
  social_description_de: NullableStringFilter
  social_description_en: NullableStringFilter
  social_title_de: NullableStringFilter
  social_title_en: NullableStringFilter
  sortKey: NullableIntFilter
}

input PageWhereUniqueInput {
  id: String
  parentPageId_slug: ParentPageIdSlugCompoundUniqueInput
  path: String
}

input ParentPageIdSlugCompoundUniqueInput {
  parentPageId: String!
  slug: String!
}

type Query {
  adminBlogPost(where: BlogPostWhereUniqueInput!): BlogPost
  adminBlogPosts(cursor: BlogPostWhereUniqueInput, orderBy: [BlogPostOrderByInput!], skip: Int, take: Int, where: BlogPostWhereInput): [BlogPost!]!
  adminBlogPostsCount(cursor: BlogPostWhereUniqueInput, orderBy: BlogPostOrderByInput, skip: Int, take: Int, where: BlogPostWhereInput): Int
  adminPage(where: PageWhereUniqueInput!): Page
  adminPages(cursor: PageWhereUniqueInput, orderBy: [PageOrderByInput!], skip: Int, take: Int, where: PageWhereInput): [Page!]!
  adminPagesCount(cursor: PageWhereUniqueInput, orderBy: PageOrderByInput, skip: Int, take: Int, where: PageWhereInput): Int
  adminUser(where: UserWhereUniqueInput!): User
  adminUsers(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  adminUsersCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int
  blogPosts(cursor: BlogPostWhereUniqueInput, skip: Int, take: Int, where: BlogPostWhereInput): [BlogPost!]!
  me: User
  page(pageId: String, path: String): Page
  pages(parentPageId: String, parentPath: String): [Page!]
}

type SignupResult {
  user: User
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  blogPosts(cursor: BlogPostWhereUniqueInput, skip: Int, take: Int): [BlogPost!]!
  email: String!
  id: String!
  roles(cursor: UserRoleWhereUniqueInput, skip: Int, take: Int): [UserRole!]!
}

input UserCreateInput {
  blogPosts: BlogPostCreateManyWithoutAuthorInput
  email: String!
  id: String
  password: String!
  roles: UserRoleCreateManyWithoutUsersInput
}

input UserCreateOneWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBlogPostsInput
}

input UserCreateWithoutBlogPostsInput {
  email: String!
  id: String
  password: String!
  roles: UserRoleCreateManyWithoutUsersInput
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  email: SortOrder
  id: SortOrder
  password: SortOrder
}

type UserRole {
  id: String!
}

input UserRoleCreateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
}

input UserRoleCreateWithoutUsersInput {
  id: String!
}

input UserRoleFilter {
  every: UserRoleWhereInput
  none: UserRoleWhereInput
  some: UserRoleWhereInput
}

input UserRoleScalarWhereInput {
  AND: [UserRoleScalarWhereInput!]
  id: StringFilter
  NOT: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  users: UserFilter
}

input UserRoleUpdateManyDataInput {
  id: String
}

input UserRoleUpdateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
  delete: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  update: [UserRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [UserRoleUpdateManyWithWhereNestedInput!]
  upsert: [UserRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input UserRoleUpdateManyWithWhereNestedInput {
  data: UserRoleUpdateManyDataInput!
  where: UserRoleScalarWhereInput!
}

input UserRoleUpdateWithoutUsersDataInput {
  id: String
}

input UserRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: UserRoleCreateWithoutUsersInput!
  update: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleWhereInput {
  AND: [UserRoleWhereInput!]
  id: StringFilter
  NOT: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  users: UserFilter
}

input UserRoleWhereUniqueInput {
  id: String
}

input UserUpdateInput {
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  email: String
  id: String
  password: String
  roles: UserRoleUpdateManyWithoutUsersInput
}

input UserUpdateManyMutationInput {
  email: String
  id: String
  password: String
}

input UserUpdateOneRequiredWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBlogPostsInput
  update: UserUpdateWithoutBlogPostsDataInput
  upsert: UserUpsertWithoutBlogPostsInput
}

input UserUpdateWithoutBlogPostsDataInput {
  email: String
  id: String
  password: String
  roles: UserRoleUpdateManyWithoutUsersInput
}

input UserUpsertWithoutBlogPostsInput {
  create: UserCreateWithoutBlogPostsInput!
  update: UserUpdateWithoutBlogPostsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  blogPosts: BlogPostFilter
  email: StringFilter
  id: UUIDFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  roles: UserRoleFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
